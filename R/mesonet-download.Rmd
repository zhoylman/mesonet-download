---
title: "Montana Mesonet Data Downloader"
output: 
  flexdashboard::flex_dashboard:
    css: /home/zhoylman/mesonet-download/css/css_modifier.css
    logo: https://climate.umt.edu/imx/MCO_logo.svg
    theme: readable
    navbar:
      - { title: "MCO GitHub", href: "https://github.com/mt-climate-office", align: right }
runtime: shiny
---

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-149859729-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag("js", new Date());
  gtag("config", "UA-149859729-3");
</script>


```{r echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(readr)
library(stringr)
library(shiny)
library(leaflet)
library(leaflet.extras)
library(ncdf4)
library(lubridate)
library(shinythemes)
library(RCurl)
library(tidyr)

source('/home/zhoylman/mesonet-download/R/base_map.R')

#bring in current station list
stations = getURL("https://mesonet.climate.umt.edu/api/stations?type=csv&clean=true") %>%
  read_csv() %>%
  arrange(`Station name`)

#bring in available variables
elements = getURL("https://mesonet.climate.umt.edu/api/elements?type=csv&clean=true") %>%
  read_csv() %>%
  arrange(Element) %>%
  mutate(Units = str_remove_all(Units, 'Ã‚'),
         new_col_names = paste0(Element, ' (', Units, ')'))

#troubleshooting data
# temp = read_csv(paste0('~/mesonet-download-data/lololowr.csv')) %>%
#   filter(name %in% c('air_temp','atmos_pr', 'precipit'),
#          datetime > as.Date('2020-12-01')) %>%
#   pivot_wider(-units)

#run app
shinyApp(ui <- fluidPage(theme = shinytheme("cosmo"),
  # build our UI defining that we want a vertical layout
  verticalLayout(),
  # first we want to display the map
  leafletOutput("mymap"),
  #add a space for aesthetics
  headerPanel(""),
  #add a horizontal line for aesthetics
  hr(),
  #set up a fluid row class for inputs
  fluidRow(align = "center",
           #first collumn (out of 12 total)
           column(4, align="center",
                  #station selection
                  selectInput("Station","Station",
                              stations$`Station name`, multiple = F),
                  #variable selection
                  selectInput("Variable","Variable(s)",
                              elements$Element, multiple = T)),
           #final collumn
           column(4, align="center", 
                  #temporal aggregation
                  selectInput("aggregation","Aggregation Interval",
                              c('No Aggregation (15 Minute Data)', 'Daily', 'Monthly'), multiple = F)),
           #second collumn 
           column(4, align="center", 
                  #date selection
                  dateInput("date_start", "Start Date"),
                  dateInput("date_end", "End Date"))
  ),
  #space for aesthetics
  headerPanel(""),
  #action button for running request
  actionButton("do", "Run Request", width = '100%'),
  #space for aesthetics
  headerPanel(""),
  hr(),
  #add a new collumn class to center the download button
  column(12, align="center",
         uiOutput("download_button", inline = T)),
  hr(),
  #add a processing message to tell the user its working
  column(12, align = 'center',
         conditionalPanel(condition="$('html').hasClass('shiny-busy')",
                          tags$div("Processing Request...",
                                   id="loadmessage"),
                          tags$style("#loadmessage{color: red;
                                 font-size: 24px;
                                 }"
                          ))
  ),
  #error message if needed
  column(12, align = 'center',
         textOutput("error_message")
         )
),
# end of User Interface (UI)
# now on to the server
server <- function(input, output, session) {
  # this is our map that we will display
  #based on the base_map() function defined above
  output$mymap <- renderLeaflet({
    base_map() %>%
      #add circle points for the station locations 
      #this will allow the user to select the station based on the map
      addCircleMarkers(data = stations, lat = ~Latitude, lng = ~Longitude, stroke = TRUE, layerId = ~`Station name`,
                           fillColor = "blue", fillOpacity = 0.5, color = "black", opacity = 0.8, radius = 6, weight = 2,
                           label = stations$`Station name`,
                           labelOptions = labelOptions(noHide = F, direction = "bottom",
                                                       style = list(
                                                         "box-shadow" = "3px 3px rgba(0,0,0,0.25)",
                                                         "font-size" = "16px"
                                                       ))) 
  })
  # Now for the truely reactive portion 
  # This will update the station selector based on clicking on the leaflet map
  observeEvent(input$mymap_marker_click, { 
    p = input$mymap_marker_click$id   
    updateSelectInput(session, "Station",
                      label = 'Station',
                      choices = stations$`Station name`,
                      selected = p
    )
  })
  #this is the main function to crunch numbers and produce final download (tabular)
  #reactive for when the user hits the 'do' button
  observeEvent(input$do, {
    tryCatch({
      #custom error handling condtions
      #no variable selected
      if(is.null(input$Variable)){
        stop()
      }
      #logical date error
      if(input$date_start > input$date_end){
        stop()
      }
      #define vars to name the download button
      #must define here or else reactive response from UI will change button names before processing data
      station_name = input$Station
      aggregation_name = input$aggregation
      #define meta data based on UI selection 
      station_meta = stations[which(stations$`Station name`==input$Station),]
      elements_meta = elements[which(elements$Element %in% input$Variable),]
      #pull in the whole dataset from flat file based on UI defined station name
      temp = read_csv(paste0('/home/zhoylman/mesonet-download-data/', station_meta$`Station ID`, '.csv')) %>%
        #filter by selected vars and time
        filter(name %in% elements_meta$`Element ID`,
               datetime >= input$date_start,
               datetime < input$date_end + 1) 
      #if the UI selects no aggregation, just clean data nd pivot wider
      if(input$aggregation == 'No Aggregation (15 Minute Data)'){
        export = temp %>% 
          pivot_wider(-units) %>%
          select(-qc_code)%>%
          mutate(datetime = as.character(datetime))
        
        #define name for export
        name = paste0("MT_Mesonet_", station_meta$`Station ID`, '_raw_data.csv')
      }
      #if the UI selects daily, then aggreate by yday
      if(input$aggregation == 'Daily'){
        export = temp %>%
          #define some time meta data for grouping
          mutate(year = year(datetime),
                 yday = yday(datetime)) %>%
          #group
          group_by(station_key, yday, year, name) %>%
          #conditional summary (precip = sum, everything else is mean)
          summarise(value = ifelse(first(name == 'precipit'), sum(value, na.rm = T), mean(value, na.rm = T))) %>%
          #recompute time
          mutate(datetime = as.POSIXct(paste(yday, year, sep = "-"), format = "%j-%Y")) %>%
          #order by time
          arrange(datetime) %>%
          #pivot wider
          pivot_wider() %>%
          #ungroup
          ungroup() %>%
          #deslect columns that are unwated
          select(., -c('yday', 'year')) %>%
          mutate(datetime = as.character(datetime))
        
        #define name for export
        name = paste0("MT_Mesonet_", station_meta$`Station ID`, '_daily_data.csv')
      }
      #if UI selects monthly aggreation 
      if(input$aggregation == 'Monthly'){
        export = temp %>%
          #define some time meta
          mutate(year = year(datetime),
                 month = month(datetime)) %>%
          #group
          group_by(station_key, month, year, name) %>%
          #conditional summary (precip = sum, everything else is mean)
          summarise(value = ifelse(first(name == 'precipit'), sum(value, na.rm = T), mean(value, na.rm = T))) %>%
          #order by time
          arrange(year,month) %>%
          #pivot wider
          pivot_wider() %>%
          #ungroup
          ungroup() 
        
        #define name for export
        name = paste0("MT_Mesonet_", station_meta$`Station ID`, '_monthly_data.csv')
      }
      # rename columns to include units 
      new_col_names = elements %>%
        filter(`Element ID` %in% colnames(export))
      export = export %>% 
        rename_at(vars(new_col_names$`Element ID`), function(x) new_col_names$new_col_names) 
      #set up download file
      output$download <- downloadHandler(
        filename = function() {
          name
        },
        content = function(filename) {
          write_csv(export, filename)
        }
      )
      #display download button only after the first process has been completed
      output$download_button <- renderUI({
        if(!is.null(export)) {
          downloadButton('download', 
                         paste0('Download Output File for ', station_name, ' [', aggregation_name, ']'))
        }
      })
      #clear error message is there was no error
      output$error_message <- renderText({
        ''
      })

    # general error handling to keep app from crashing  
    }, error = function(e){
      #custom error messages based on specific circumstances
      message = ifelse(is.null(input$Variable), 'Please select a variable to download.',
                       ifelse(input$date_start > input$date_end, 
                              '"Start Date" must be equal to or earlier than "End Date".', 'Oops, there seams to be an error...'))
      
      output$error_message <- renderText({
          message
        })
      
    })
  })
},  options = list(height = 1000))

#fin
```
